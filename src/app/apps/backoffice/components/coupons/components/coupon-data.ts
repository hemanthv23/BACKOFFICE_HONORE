import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError } from 'rxjs';
import { catchError, tap, map, switchMap } from 'rxjs/operators';

import { Coupon, CouponStatusEnum, CouponTypeEnum } from '../interfaces';

@Injectable({
    providedIn: 'root' // Makes this service a singleton available throughout your application
})
export class CouponData {
    private apiUrl = 'https://localhost:7233/api/Coupons'; // Base API URL

    // BehaviorSubject to hold and emit the current list of coupons reactively
    // Components can subscribe to allCoupons$ to get the latest data
    public allCoupons$: BehaviorSubject<Coupon[]> = new BehaviorSubject<Coupon[]>([]);

    constructor(private http: HttpClient) {
        // No initial data generation here; data will be fetched from API when requested
    }

    /**
     * Fetches all coupons from the API and updates the BehaviorSubject.
     * @returns An Observable of an array of Coupons.
     */
    getAllCoupons(): Observable<Coupon[]> {
        return this.http.get<Coupon[]>(this.apiUrl).pipe(
            tap((coupons) => {
                // Update the BehaviorSubject so all subscribers get the new list
                this.allCoupons$.next(coupons);
                console.log('Coupons fetched from API:', coupons);
            }),
            catchError(this.handleError<Coupon[]>('getAllCoupons', []))
        );
    }

    /**
     * Fetches a single coupon by its ID from the API.
     * @param id The ID of the coupon to fetch.
     * @returns An Observable of a single Coupon.
     */
    getCouponById(id: number): Observable<Coupon> {
        const url = `${this.apiUrl}/${id}`;
        return this.http.get<Coupon>(url).pipe(catchError(this.handleError<Coupon>(`getCouponById id=${id}`)));
    }

    /**
     * Adds a new coupon to the backend via POST request.
     * After successful addition, updates the local list of coupons.
     * @param coupon The coupon object to add (ID, createdAt, updatedAt are usually ignored/generated by backend).
     * @returns An Observable of the newly created Coupon.
     */
    addCoupon(coupon: Coupon): Observable<Coupon> {
        // Prepare the coupon object to send, omitting backend-generated fields if necessary
        // Based on your API's req body, 'id', 'createdAt', 'updatedAt' should be omitted
        const couponToSend = {
            name: coupon.name,
            code: coupon.code,
            description: coupon.description,
            discountType: coupon.discountType,
            discountValue: coupon.discountValue,
            status: coupon.status,
            startDate: coupon.startDate,
            endDate: coupon.endDate,
            usageCount: coupon.usageCount,
            maxUsage: coupon.maxUsage,
            customerName: coupon.customerName,
            communityName: coupon.communityName,
            type: coupon.type
            // id, createdAt, updatedAt are typically generated by the backend
        };

        return this.http.post<Coupon>(this.apiUrl, couponToSend).pipe(
            tap((newCoupon) => {
                // Add the newly created coupon to the current list
                const currentCoupons = this.allCoupons$.getValue();
                this.allCoupons$.next([...currentCoupons, newCoupon]);
                console.log('Coupon added via API:', newCoupon);
            }),
            catchError(this.handleError<Coupon>('addCoupon'))
        );
    }

    /**
     * Updates an existing coupon in the backend via PUT request.
     * After successful update, updates the local list of coupons.
     * @param updatedCoupon The full updated coupon object.
     * @returns An Observable indicating the success of the operation.
     */
    updateCoupon(updatedCoupon: Coupon): Observable<any> {
        const url = `${this.apiUrl}/${updatedCoupon.id}`;
        return this.http.put(url, updatedCoupon).pipe(
            tap(() => {
                // Find and replace the updated coupon in the current list
                const currentCoupons = this.allCoupons$.getValue();
                const index = currentCoupons.findIndex((c) => c.id === updatedCoupon.id);
                if (index !== -1) {
                    currentCoupons[index] = updatedCoupon;
                    this.allCoupons$.next([...currentCoupons]); // Emit updated list to subscribers
                    console.log('Coupon updated via API:', updatedCoupon);
                }
            }),
            catchError(this.handleError<any>('updateCoupon'))
        );
    }

    /**
     * Deletes a coupon from the backend via DELETE request.
     * After successful deletion, removes the coupon from the local list.
     * @param id The ID of the coupon to delete.
     * @returns An Observable indicating the success of the operation.
     */
    deleteCoupon(id: number): Observable<any> {
        const url = `${this.apiUrl}/${id}`;
        return this.http.delete(url).pipe(
            tap(() => {
                // Filter out the deleted coupon from the current list
                const currentCoupons = this.allCoupons$.getValue();
                this.allCoupons$.next(currentCoupons.filter((coupon) => coupon.id !== id));
                console.log('Coupon deleted via API:', id);
            }),
            catchError(this.handleError<any>('deleteCoupon'))
        );
    }

    /**
     * Updates the status of a coupon by fetching it, modifying its status, and then calling updateCoupon.
     * @param id The ID of the coupon whose status is to be updated.
     * @param newStatus The new status for the coupon.
     * @returns An Observable indicating the success of the operation.
     */
    updateCouponStatus(id: number, newStatus: CouponStatusEnum): Observable<any> {
        // Fetch the coupon first to get its current data
        return this.getCouponById(id).pipe(
            map((coupon) => {
                if (!coupon) {
                    throw new Error(`Coupon with ID ${id} not found.`);
                }
                // Create a new object to avoid direct mutation and ensure immutability
                // Also update the 'updatedAt' timestamp as per common API practice
                const updatedCoupon = { ...coupon, status: newStatus, updatedAt: new Date().toISOString() };
                return updatedCoupon;
            }),
            // Use switchMap to flatten the Observable of the inner updateCoupon call
            switchMap((updatedCoupon) => this.updateCoupon(updatedCoupon)),
            catchError(this.handleError<any>('updateCouponStatus'))
        );
    }

    /**
     * Retrieves all coupons specifically designated for customers (Type = 0).
     * @returns An Observable of an array of Customer Coupons.
     */
    getCustomerCoupons(): Observable<Coupon[]> {
        const url = `${this.apiUrl}/customer`;
        return this.http.get<Coupon[]>(url).pipe(catchError(this.handleError<Coupon[]>('getCustomerCoupons', [])));
    }

    /**
     * Retrieves all coupons specifically designated for communities (Type = 1).
     * @returns An Observable of an array of Community Coupons.
     */
    getCommunityCoupons(): Observable<Coupon[]> {
        const url = `${this.apiUrl}/community`;
        return this.http.get<Coupon[]>(url).pipe(catchError(this.handleError<Coupon[]>('getCommunityCoupons', [])));
    }

    /**
     * Searches for coupons based on their name.
     * @param name The name or part of the name to search for.
     * @returns An Observable of an array of matching Coupons.
     */
    searchCouponsByName(name: string): Observable<Coupon[]> {
        let httpParams = new HttpParams();
        if (name) {
            httpParams = httpParams.set('name', name);
        }
        const url = `${this.apiUrl}/search`;
        return this.http.get<Coupon[]>(url, { params: httpParams }).pipe(catchError(this.handleError<Coupon[]>('searchCouponsByName', [])));
    }

    /**
     * Generic error handling function for HTTP requests.
     * @param operation Name of the operation that failed.
     * @param result Optional value to return as the observable result.
     * @returns A function that returns an Observable with a user-facing error message.
     */
    private handleError<T>(operation = 'operation', result?: T) {
        return (error: any): Observable<T> => {
            console.error(`API Error - ${operation}:`, error); // Log the error to console
            // You might want to display a user-friendly message in your UI here
            // e.g., using a notification service.

            // Re-throw the error to ensure the component calling this method can handle it
            return throwError(() => new Error(`An error occurred during ${operation}. Please try again later. Details: ${error.message || error.statusText || 'Unknown error'}`));
        };
    }
}
